# generated by datamodel-codegen:
#   filename:  promptius-gui-schema.json
#   timestamp: 2025-11-01T10:03:17+00:00

from __future__ import annotations

from enum import Enum
from typing import List, Literal, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel, conint, constr


class ButtonVariant(Enum):
    primary = 'primary'
    secondary = 'secondary'
    outline = 'outline'
    ghost = 'ghost'
    destructive = 'destructive'


class ButtonSize(Enum):
    sm = 'sm'
    md = 'md'
    lg = 'lg'


class InputType(Enum):
    text = 'text'
    email = 'email'
    password = 'password'
    number = 'number'
    tel = 'tel'
    url = 'url'
    search = 'search'
    date = 'date'


class InputSize(Enum):
    sm = 'sm'
    md = 'md'
    lg = 'lg'


class AlertVariant(Enum):
    info = 'info'
    success = 'success'
    warning = 'warning'
    error = 'error'


class TextTag(Enum):
    h1 = 'h1'
    h2 = 'h2'
    h3 = 'h3'
    h4 = 'h4'
    h5 = 'h5'
    h6 = 'h6'
    p = 'p'
    span = 'span'
    label = 'label'


class AlignText(Enum):
    left = 'left'
    center = 'center'
    right = 'right'
    justify = 'justify'


class FlexDirection(Enum):
    row = 'row'
    column = 'column'


class ChartType(Enum):
    bar = 'bar'
    line = 'line'
    pie = 'pie'


class EventType(Enum):
    onClick = 'onClick'
    onSubmit = 'onSubmit'
    onChange = 'onChange'
    onFocus = 'onFocus'
    onBlur = 'onBlur'


class Target(Enum):
    field_self = '_self'
    field_blank = '_blank'


class NavigateAction(BaseModel):
    type: Literal['navigate']
    url: constr(min_length=1) = Field(..., description='URL or route to navigate to')
    target: Optional[Target] = Field('_self', description='Navigation target window')


class SetStateAction(BaseModel):
    type: Literal['setState']
    key: constr(min_length=1) = Field(..., description='State key to update')
    value: Union[str, float, bool] = Field(..., description='Value to set')


class Method(Enum):
    POST = 'POST'
    PUT = 'PUT'
    PATCH = 'PATCH'


class SubmitFormAction(BaseModel):
    type: Literal['submitForm']
    endpoint: Optional[str] = Field(None, description='API endpoint to submit to')
    method: Optional[Method] = Field(
        'POST', description='HTTP method for form submission'
    )


class ValidateAction(BaseModel):
    type: Literal['validate']
    rules: Optional[List[str]] = Field([], description='Validation rules')


class CustomAction(BaseModel):
    type: Literal['custom']
    handler: constr(min_length=1) = Field(
        ..., description='Name of custom handler function'
    )


EventAction = Union[
    NavigateAction,
    SetStateAction,
    SubmitFormAction,
    ValidateAction,
    CustomAction,
]


class ButtonProps(BaseModel):
    label: constr(min_length=1) = Field(..., description='Button text')
    variant: Optional[ButtonVariant] = 'primary'
    size: Optional[ButtonSize] = 'md'
    disabled: Optional[bool] = False
    fullWidth: Optional[bool] = False
    loading: Optional[bool] = False


class InputProps(BaseModel):
    placeholder: Optional[str] = Field('', description='Placeholder text')
    type: Optional[InputType] = 'text'
    size: Optional[InputSize] = 'md'
    disabled: Optional[bool] = False
    required: Optional[bool] = False
    label: Optional[str] = Field(None, description='Input label')
    helperText: Optional[str] = Field(None, description='Helper text below input')
    defaultValue: Optional[str] = Field(None, description='Default input value')
    maxLength: Optional[conint(ge=1)] = Field(None, description='Maximum input length')
    minLength: Optional[conint(ge=0)] = Field(None, description='Minimum input length')


class TextareaProps(BaseModel):
    placeholder: Optional[str] = Field('', description='Placeholder text')
    rows: Optional[conint(ge=1, le=20)] = Field(
        4, description='Number of textarea rows'
    )
    disabled: Optional[bool] = False
    required: Optional[bool] = False
    label: Optional[str] = Field(None, description='Textarea label')
    helperText: Optional[str] = Field(None, description='Helper text below textarea')
    maxLength: Optional[conint(ge=1)] = Field(
        None, description='Maximum textarea length'
    )


class TextProps(BaseModel):
    content: str = Field(..., description='Text content')
    tag: Optional[TextTag] = 'p'
    align: Optional[AlignText] = 'left'
    bold: Optional[bool] = False
    italic: Optional[bool] = False
    color: Optional[constr(pattern=r'^(#[0-9A-Fa-f]{6}|[a-z\-]+)$')] = Field(
        None, description='Text color (hex or CSS color name)'
    )


class CardProps(BaseModel):
    title: Optional[str] = Field(None, description='Card title')
    description: Optional[str] = Field(None, description='Card description')
    elevation: Optional[conint(ge=0, le=5)] = Field(
        1, description='Card elevation level'
    )
    padding: Optional[conint(ge=0, le=64)] = Field(
        16, description='Card padding in pixels'
    )


class AlertProps(BaseModel):
    message: constr(min_length=1) = Field(..., description='Alert message')
    title: Optional[str] = Field(None, description='Alert title')
    variant: Optional[AlertVariant] = 'info'
    dismissible: Optional[bool] = False


class ContainerProps(BaseModel):
    maxWidth: Optional[conint(ge=320, le=1920)] = Field(
        None, description='Maximum container width in pixels'
    )
    padding: Optional[conint(ge=0, le=64)] = Field(
        16, description='Container padding in pixels'
    )
    centered: Optional[bool] = False


class GridProps(BaseModel):
    columns: conint(ge=1, le=12) = Field(..., description='Number of columns')
    gap: Optional[conint(ge=0, le=64)] = Field(
        16, description='Gap between items in pixels'
    )
    responsive: Optional[bool] = Field(True, description='Enable responsive behavior')


class Align(Enum):
    start = 'start'
    center = 'center'
    end = 'end'
    stretch = 'stretch'


class StackProps(BaseModel):
    direction: Optional[FlexDirection] = 'column'
    gap: Optional[conint(ge=0, le=64)] = Field(
        8, description='Gap between items in pixels'
    )
    align: Optional[Align] = Field('stretch', description='Alignment of items')


class ChartSeries(BaseModel):
    name: Optional[str] = Field(None, description='Series name')
    data: List[float] = Field(..., description='Series data points', min_length=1)


class AxisXProps(BaseModel):
    label: Optional[str] = Field(None, description='X-axis label')
    ticks: Optional[List[str]] = Field(None, description='X-axis tick labels')
    showGrid: Optional[bool] = False


class AxisYProps(BaseModel):
    label: Optional[str] = Field(None, description='Y-axis label')
    min: Optional[float] = Field(None, description='Y-axis minimum value')
    max: Optional[float] = Field(None, description='Y-axis maximum value')
    showGrid: Optional[bool] = False


class ChartAnnotation(BaseModel):
    x: Optional[float] = Field(None, description='X coordinate')
    y: Optional[float] = Field(None, description='Y coordinate')
    label: str = Field(..., description='Annotation label')


class LegendPosition(Enum):
    top = 'top'
    right = 'right'
    bottom = 'bottom'
    left = 'left'


class ChartProps(BaseModel):
    chartType: ChartType = Field(..., description='Chart visualization type')
    width: Optional[conint(ge=100, le=4000)] = Field(
        None, description='Chart width in pixels'
    )
    height: Optional[conint(ge=100, le=4000)] = Field(
        None, description='Chart height in pixels'
    )
    labels: Optional[List[str]] = Field(None, description='Chart category labels')
    series: List[ChartSeries] = Field(
        ..., description='Chart data series', min_length=1
    )
    colors: Optional[List[str]] = Field(None, description='Custom chart colors')
    title: Optional[str] = Field(None, description='Chart title')
    showLegend: Optional[bool] = True
    legendPosition: Optional[LegendPosition] = 'top'
    xAxis: Optional[AxisXProps] = None
    yAxis: Optional[AxisYProps] = None
    annotations: Optional[List[ChartAnnotation]] = Field(
        None, description='Chart annotations'
    )


class ButtonNode(BaseModel):
    id: constr(min_length=1) = Field(
        ...,
        description='Unique node identifier. This id must be unique across all nodes in the nodes array. It is used to reference this node in edges (as src or dest) and events (as nodeId). The rootId in metadata must match one of these ids.',
    )
    type: Literal['button']
    props: ButtonProps


class InputNode(BaseModel):
    id: constr(min_length=1) = Field(
        ...,
        description='Unique node identifier. This id must be unique across all nodes in the nodes array. It is used to reference this node in edges (as src or dest) and events (as nodeId). The rootId in metadata must match one of these ids.',
    )
    type: Literal['input']
    props: InputProps


class TextareaNode(BaseModel):
    id: constr(min_length=1) = Field(
        ...,
        description='Unique node identifier. This id must be unique across all nodes in the nodes array. It is used to reference this node in edges (as src or dest) and events (as nodeId). The rootId in metadata must match one of these ids.',
    )
    type: Literal['textarea']
    props: TextareaProps


class TextNode(BaseModel):
    id: constr(min_length=1) = Field(
        ...,
        description='Unique node identifier. This id must be unique across all nodes in the nodes array. It is used to reference this node in edges (as src or dest) and events (as nodeId). The rootId in metadata must match one of these ids.',
    )
    type: Literal['text']
    props: TextProps


class CardNode(BaseModel):
    id: constr(min_length=1) = Field(
        ...,
        description='Unique node identifier. This id must be unique across all nodes in the nodes array. It is used to reference this node in edges (as src or dest) and events (as nodeId). The rootId in metadata must match one of these ids.',
    )
    type: Literal['card']
    props: CardProps


class AlertNode(BaseModel):
    id: constr(min_length=1) = Field(
        ...,
        description='Unique node identifier. This id must be unique across all nodes in the nodes array. It is used to reference this node in edges (as src or dest) and events (as nodeId). The rootId in metadata must match one of these ids.',
    )
    type: Literal['alert']
    props: AlertProps


class ContainerNode(BaseModel):
    id: constr(min_length=1) = Field(
        ...,
        description='Unique node identifier. This id must be unique across all nodes in the nodes array. It is used to reference this node in edges (as src or dest) and events (as nodeId). The rootId in metadata must match one of these ids.',
    )
    type: Literal['container']
    props: ContainerProps


class GridNode(BaseModel):
    id: constr(min_length=1) = Field(
        ...,
        description='Unique node identifier. This id must be unique across all nodes in the nodes array. It is used to reference this node in edges (as src or dest) and events (as nodeId). The rootId in metadata must match one of these ids.',
    )
    type: Literal['grid']
    props: GridProps


class StackNode(BaseModel):
    id: constr(min_length=1) = Field(
        ...,
        description='Unique node identifier. This id must be unique across all nodes in the nodes array. It is used to reference this node in edges (as src or dest) and events (as nodeId). The rootId in metadata must match one of these ids.',
    )
    type: Literal['stack']
    props: StackProps


class ChartNode(BaseModel):
    id: constr(min_length=1) = Field(
        ...,
        description='Unique node identifier. This id must be unique across all nodes in the nodes array. It is used to reference this node in edges (as src or dest) and events (as nodeId). The rootId in metadata must match one of these ids.',
    )
    type: Literal['chart']
    props: ChartProps


class Node(
    RootModel[
        Union[
            ButtonNode,
            InputNode,
            TextareaNode,
            TextNode,
            CardNode,
            AlertNode,
            ContainerNode,
            GridNode,
            StackNode,
            ChartNode,
        ]
    ]
):
    root: Union[
        ButtonNode,
        InputNode,
        TextareaNode,
        TextNode,
        CardNode,
        AlertNode,
        ContainerNode,
        GridNode,
        StackNode,
        ChartNode,
    ] = Field(
        ...,
        description="A UI component node with a unique id (must be unique across all nodes), a type that determines the component type (button, input, container, etc.), and props that define the component's properties and behavior. Each node's id may be referenced by edges (as src or dest) and events (as nodeId).",
        discriminator='type',
    )


class Edge(BaseModel):
    src: constr(min_length=1) = Field(
        ...,
        description='The ID of the parent node. This MUST match the id of a node in the nodes array. The parent node will contain this child as a nested component.',
    )
    dest: constr(min_length=1) = Field(
        ...,
        description='The ID of the child node. This MUST match the id of a node in the nodes array. This child will be rendered inside the parent node (src).',
    )
    order: conint(ge=0) = Field(
        ...,
        description='The rendering order among sibling children. Lower numbers are rendered first. If multiple edges have the same parent (src), their children will be rendered in ascending order of this value.',
    )


class Event(BaseModel):
    nodeId: constr(min_length=1) = Field(
        ...,
        description='The ID of the node to bind this event to. This MUST match the id of a node in the nodes array. When the specified eventType occurs on this node, the associated action will be executed.',
    )
    eventType: EventType
    action: EventAction


class Framework(Enum):
    shadcn = 'shadcn'
    material_ui = 'material-ui'
    chakra_ui = 'chakra-ui'
    ant_design = 'ant-design'


class UIMetadata(BaseModel):
    title: constr(min_length=1) = Field(..., description='UI schema title')
    description: Optional[str] = Field(None, description='UI schema description')
    version: Optional[constr(pattern=r'^\d+\.\d+\.\d+$')] = Field(
        '1.0.0', description='Schema version'
    )
    framework: Optional[Framework] = Field('shadcn', description='Target UI framework')
    rootId: constr(min_length=1) = Field(
        ...,
        description='The ID of the root node that serves as the entry point for rendering the UI tree. This value MUST match the id field of exactly one node in the nodes array. The renderer will start building the UI hierarchy from this root node and traverse the edges to render child components in the specified order.',
    )


class PromptiusGuiSchema(BaseModel):
    metadata: UIMetadata
    nodes: List[Node] = Field(
        ...,
        description='Array of all UI component nodes. Each node represents a UI component (button, input, container, etc.) with a unique id. The rootId specified in metadata.rootId MUST exist as one of these node ids.',
        min_length=1,
    )
    edges: List[Edge] = Field(
        ...,
        description="Array of edges defining parent-child relationships in the component tree. Each edge connects a parent node (src) to a child node (dest) and specifies the rendering order (order). Edges define the hierarchical structure: nodes without incoming edges are top-level, and children are nested within their parent components. If a node has no edges pointing to it, it is an orphan and won't be rendered unless it's the root node.",
    )
    events: List[Event] = Field(
        ...,
        description='Array of event bindings that connect user interactions (onClick, onSubmit, onChange, etc.) to specific nodes. Each event specifies the nodeId (which MUST exist in the nodes array), the eventType, and the action to perform when the event is triggered.',
    )
